var I = Object.defineProperty;
var j = (e, t, i) => t in e ? I(e, t, { enumerable: !0, configurable: !0, writable: !0, value: i }) : e[t] = i;
var d = (e, t, i) => (j(e, typeof t != "symbol" ? t + "" : t, i), i);
import { debounce as M } from "@yeger/debounce";
import { select as w } from "d3-selection";
import { Vector as k } from "vecti";
import { zoomIdentity as E, zoom as U } from "d3-zoom";
import { drag as Z } from "d3-drag";
import { forceSimulation as W, forceX as H, forceY as V, forceManyBody as X, forceCollide as Y, forceLink as q } from "d3-force";
function P() {
  return {
    drag: {
      end: 0,
      start: 0.1
    },
    filter: {
      link: 1,
      type: 0.1,
      unlinked: {
        include: 0.1,
        exclude: 0.1
      }
    },
    focus: {
      acquire: () => 0.1,
      release: () => 0.1
    },
    initialize: 1,
    labels: {
      links: {
        hide: 0,
        show: 0
      },
      nodes: {
        hide: 0,
        show: 0
      }
    },
    resize: 0.5
  };
}
function F(e) {
  if (typeof e == "object" && e !== null) {
    if (typeof Object.getPrototypeOf == "function") {
      const t = Object.getPrototypeOf(e);
      return t === Object.prototype || t === null;
    }
    return Object.prototype.toString.call(e) === "[object Object]";
  }
  return !1;
}
function m(...e) {
  return e.reduce((t, i) => {
    if (Array.isArray(i))
      throw new TypeError(
        "Arguments provided to deepmerge must be objects, not arrays."
      );
    return Object.keys(i).forEach((n) => {
      ["__proto__", "constructor", "prototype"].includes(n) || (Array.isArray(t[n]) && Array.isArray(i[n]) ? t[n] = m.options.mergeArrays ? Array.from(new Set(t[n].concat(i[n]))) : i[n] : F(t[n]) && F(i[n]) ? t[n] = m(t[n], i[n]) : t[n] = i[n]);
    }), t;
  }, {});
}
const $ = {
  mergeArrays: !0
};
m.options = $;
m.withOptions = (e, ...t) => {
  m.options = {
    mergeArrays: !0,
    ...e
  };
  const i = m(...t);
  return m.options = $, i;
};
function K() {
  return {
    centering: {
      enabled: !0,
      strength: 0.1
    },
    charge: {
      enabled: !0,
      strength: -1
    },
    collision: {
      enabled: !0,
      strength: 1,
      radiusMultiplier: 2
    },
    link: {
      enabled: !0,
      strength: 1,
      length: 128
    }
  };
}
function J() {
  return {
    includeUnlinked: !0,
    linkFilter: () => !0,
    nodeTypeFilter: void 0,
    showLinkLabels: !0,
    showNodeLabels: !0
  };
}
function z(e) {
  e.preventDefault(), e.stopPropagation();
}
function O(e) {
  return typeof e == "number";
}
function g(e, t) {
  return O(e.nodeRadius) ? e.nodeRadius : e.nodeRadius(t);
}
function Q(e) {
  return `${e.source.id}-${e.target.id}`;
}
function A(e) {
  return `link-arrow-${e}`.replace(/[()]/g, "~");
}
function tt(e) {
  return `url(#${A(e.color)})`;
}
function et(e) {
  return {
    size: e,
    padding: (t, i) => g(i, t) + 2 * e,
    ref: [e / 2, e / 2],
    path: [
      [0, 0],
      [0, e],
      [e, e / 2]
    ],
    viewBox: [0, 0, e, e].join(",")
  };
}
const it = {
  /**
   * Create an arrow marker configuration.
   * @param size - The size of the arrow
   */
  Arrow: (e) => et(e)
}, nt = (e, t, i) => [t / 2, i / 2], C = (e, t, i) => [N(0, t), N(0, i)];
function N(e, t) {
  return Math.random() * (t - e) + e;
}
function rt(e) {
  const t = Object.fromEntries(
    e.nodes.map((i) => [i.id, [i.x, i.y]])
  );
  return (i, n, r) => {
    const [o, a] = t[i.id] ?? [];
    return !o || !a ? C(i, n, r) : [o, a];
  };
}
const st = {
  /**
   * Initializes node positions to a graph's center.
   */
  Centered: nt,
  /**
   * Randomly initializes node positions within the visible area.
   */
  Randomized: C,
  /**
   * Initializes node positions based on other graph.
   */
  Stable: rt
};
function ot() {
  return {
    autoResize: !1,
    callbacks: {},
    hooks: {},
    initial: J(),
    nodeRadius: 16,
    marker: it.Arrow(4),
    modifiers: {},
    positionInitializer: st.Centered,
    simulation: {
      alphas: P(),
      forces: K()
    },
    zoom: {
      initial: 1,
      min: 0.1,
      max: 2
    }
  };
}
function Ht(e = {}) {
  return m.withOptions(
    { mergeArrays: !1 },
    ot(),
    e
  );
}
function at({
  applyZoom: e,
  container: t,
  onDoubleClick: i,
  onPointerMoved: n,
  onPointerUp: r,
  offset: [o, a],
  scale: s,
  zoom: l
}) {
  const c = t.classed("graph", !0).append("svg").attr("height", "100%").attr("width", "100%").call(l).on("contextmenu", (h) => z(h)).on("dblclick", (h) => i == null ? void 0 : i(h)).on("dblclick.zoom", null).on("pointermove", (h) => n == null ? void 0 : n(h)).on("pointerup", (h) => r == null ? void 0 : r(h)).style("cursor", "grab");
  return e && c.call(
    l.transform,
    E.translate(o, a).scale(s)
  ), c.append("g");
}
function lt({
  canvas: e,
  scale: t,
  xOffset: i,
  yOffset: n
}) {
  e == null || e.attr("transform", `translate(${i},${n})scale(${t})`);
}
function ct({
  config: e,
  onDragStart: t,
  onDragEnd: i
}) {
  var r, o;
  const n = Z().filter((a) => a.type === "mousedown" ? a.button === 0 : a.type === "touchstart" ? a.touches.length === 1 : !1).on("start", (a, s) => {
    a.active === 0 && t(a, s), w(a.sourceEvent.target).classed("grabbed", !0), s.fx = s.x, s.fy = s.y;
  }).on("drag", (a, s) => {
    s.fx = a.x, s.fy = a.y;
  }).on("end", (a, s) => {
    a.active === 0 && i(a, s), w(a.sourceEvent.target).classed("grabbed", !1), s.fx = void 0, s.fy = void 0;
  });
  return (o = (r = e.modifiers).drag) == null || o.call(r, n), n;
}
function dt({
  graph: e,
  filter: t,
  focusedNode: i,
  includeUnlinked: n,
  linkFilter: r
}) {
  const o = e.links.filter(
    (l) => t.includes(l.source.type) && t.includes(l.target.type) && r(l)
  ), a = (l) => o.find(
    (c) => c.source.id === l.id || c.target.id === l.id
  ) !== void 0, s = e.nodes.filter(
    (l) => t.includes(l.type) && (n || a(l))
  );
  return i === void 0 || !t.includes(i.type) ? {
    nodes: s,
    links: o
  } : ht({ nodes: s, links: o }, i);
}
function ht(e, t) {
  const i = [
    ...ut(e, t),
    ...ft(e, t)
  ], n = i.flatMap((r) => [r.source, r.target]);
  return {
    nodes: [.../* @__PURE__ */ new Set([...n, t])],
    links: [...new Set(i)]
  };
}
function ut(e, t) {
  return G(
    e,
    t,
    (i, n) => i.target.id === n.id
  );
}
function ft(e, t) {
  return G(
    e,
    t,
    (i, n) => i.source.id === n.id
  );
}
function G(e, t, i) {
  const n = new Set(e.links), r = /* @__PURE__ */ new Set([t]), o = [];
  for (; n.size > 0; ) {
    const a = [...n].filter(
      (s) => [...r].some((l) => i(s, l))
    );
    if (a.length === 0)
      return o;
    a.forEach((s) => {
      r.add(s.source), r.add(s.target), o.push(s), n.delete(s);
    });
  }
  return o;
}
function L(e) {
  return e.x ?? 0;
}
function v(e) {
  return e.y ?? 0;
}
function _({ source: e, target: t }) {
  const i = new k(L(e), v(e)), n = new k(L(t), v(t)), r = n.subtract(i), o = r.length(), a = r.normalize(), s = a.multiply(-1);
  return {
    s: i,
    t: n,
    dist: o,
    norm: a,
    endNorm: s
  };
}
function B({ center: e, node: t }) {
  const i = new k(L(t), v(t));
  let n = e;
  return i.x === n.x && i.y === n.y && (n = n.add(new k(0, 1))), {
    n: i,
    c: n
  };
}
function D({ config: e, source: t, target: i }) {
  const { s: n, t: r, norm: o } = _({ config: e, source: t, target: i }), a = n.add(o.multiply(g(e, t) - 1)), s = r.subtract(o.multiply(e.marker.padding(i, e)));
  return {
    start: a,
    end: s
  };
}
function pt(e) {
  const { start: t, end: i } = D(e);
  return `M${t.x},${t.y}
          L${i.x},${i.y}`;
}
function mt(e) {
  const { start: t, end: i } = D(e), n = i.subtract(t).multiply(0.5), r = t.add(n);
  return `translate(${r.x - 8},${r.y - 4})`;
}
function gt({ config: e, source: t, target: i }) {
  const { s: n, t: r, dist: o, norm: a, endNorm: s } = _({
    config: e,
    source: t,
    target: i
  }), l = 10, c = a.rotateByDegrees(-l).multiply(g(e, t) - 1).add(n), h = s.rotateByDegrees(l).multiply(g(e, i)).add(r).add(s.rotateByDegrees(l).multiply(2 * e.marker.size)), p = 1.2 * o;
  return `M${c.x},${c.y}
          A${p},${p},0,0,1,${h.x},${h.y}`;
}
function yt({ center: e, config: t, node: i }) {
  const { n, c: r } = B({ center: e, config: t, node: i }), o = g(t, i), a = n.subtract(r), s = a.multiply(1 / a.length()), l = 40, c = s.rotateByDegrees(l).multiply(o - 1).add(n), h = s.rotateByDegrees(-l).multiply(o).add(n).add(s.rotateByDegrees(-l).multiply(2 * t.marker.size));
  return `M${c.x},${c.y}
          A${o},${o},0,1,0,${h.x},${h.y}`;
}
function kt({ config: e, source: t, target: i }) {
  const { t: n, dist: r, endNorm: o } = _({ config: e, source: t, target: i }), s = o.rotateByDegrees(10).multiply(0.5 * r).add(n);
  return `translate(${s.x},${s.y})`;
}
function bt({ center: e, config: t, node: i }) {
  const { n, c: r } = B({ center: e, config: t, node: i }), o = n.subtract(r), a = o.multiply(1 / o.length()).multiply(3 * g(t, i) + 8).add(n);
  return `translate(${a.x},${a.y})`;
}
const y = {
  line: {
    labelTransform: mt,
    path: pt
  },
  arc: {
    labelTransform: kt,
    path: gt
  },
  reflexive: {
    labelTransform: bt,
    path: yt
  }
};
function wt(e) {
  return e.append("g").classed("links", !0).selectAll("path");
}
function xt({
  config: e,
  graph: t,
  selection: i,
  showLabels: n
}) {
  const r = i == null ? void 0 : i.data(t.links, (o) => Q(o)).join((o) => {
    var c, h, p, b;
    const a = o.append("g"), s = a.append("path").classed("link", !0).style("marker-end", (f) => tt(f)).style("stroke", (f) => f.color);
    (h = (c = e.modifiers).link) == null || h.call(c, s);
    const l = a.append("text").classed("link__label", !0).style("fill", (f) => f.label ? f.label.color : null).style("font-size", (f) => f.label ? f.label.fontSize : null).text((f) => f.label ? f.label.text : null);
    return (b = (p = e.modifiers).linkLabel) == null || b.call(p, l), a;
  });
  return r == null || r.select(".link__label").attr("opacity", (o) => o.label && n ? 1 : 0), r;
}
function Lt(e) {
  vt(e), _t(e);
}
function vt({
  center: e,
  config: t,
  graph: i,
  selection: n
}) {
  n == null || n.selectAll("path").attr("d", (r) => r.source.x === void 0 || r.source.y === void 0 || r.target.x === void 0 || r.target.y === void 0 ? "" : r.source.id === r.target.id ? y.reflexive.path({
    config: t,
    node: r.source,
    center: e
  }) : R(i, r.source, r.target) ? y.arc.path({ config: t, source: r.source, target: r.target }) : y.line.path({ config: t, source: r.source, target: r.target }));
}
function _t({
  config: e,
  center: t,
  graph: i,
  selection: n
}) {
  n == null || n.select(".link__label").attr("transform", (r) => r.source.x === void 0 || r.source.y === void 0 || r.target.x === void 0 || r.target.y === void 0 ? "translate(0, 0)" : r.source.id === r.target.id ? y.reflexive.labelTransform({
    config: e,
    node: r.source,
    center: t
  }) : R(i, r.source, r.target) ? y.arc.labelTransform({
    config: e,
    source: r.source,
    target: r.target
  }) : y.line.labelTransform({
    config: e,
    source: r.source,
    target: r.target
  }));
}
function R(e, t, i) {
  return t.id !== i.id && e.links.some(
    (n) => n.target.id === t.id && n.source.id === i.id
  ) && e.links.some(
    (n) => n.target.id === i.id && n.source.id === t.id
  );
}
function Tt(e) {
  return e.append("defs").selectAll("marker");
}
function St({
  config: e,
  graph: t,
  selection: i
}) {
  return i == null ? void 0 : i.data(Ft(t), (n) => n).join((n) => {
    const r = n.append("marker").attr("id", (o) => A(o)).attr("markerHeight", 4 * e.marker.size).attr("markerWidth", 4 * e.marker.size).attr("markerUnits", "userSpaceOnUse").attr("orient", "auto").attr("refX", e.marker.ref[0]).attr("refY", e.marker.ref[1]).attr("viewBox", e.marker.viewBox).style("fill", (o) => o);
    return r.append("path").attr("d", Nt(e.marker.path)), r;
  });
}
function Ft(e) {
  return [...new Set(e.links.map((t) => t.color))];
}
function Nt(e) {
  const [t, ...i] = e;
  if (!t)
    return "M0,0";
  const [n, r] = t;
  return i.reduce(
    (o, [a, s]) => `${o}L${a},${s}`,
    `M${n},${r}`
  );
}
function $t(e) {
  return e.append("g").classed("nodes", !0).selectAll("circle");
}
function zt({
  config: e,
  drag: t,
  graph: i,
  onNodeContext: n,
  onNodeSelected: r,
  selection: o,
  showLabels: a
}) {
  const s = o == null ? void 0 : o.data(i.nodes, (l) => l.id).join((l) => {
    var b, f, T, S;
    const c = l.append("g");
    t !== void 0 && c.call(t);
    const h = c.append("circle").classed("node", !0).attr("r", (u) => g(e, u)).on("contextmenu", (u, x) => {
      z(u), n(x);
    }).on("pointerdown", (u, x) => At(u, x, r ?? n)).style("fill", (u) => u.color);
    (f = (b = e.modifiers).node) == null || f.call(b, h);
    const p = c.append("text").classed("node__label", !0).attr("dy", "0.33em").style("fill", (u) => u.label ? u.label.color : null).style("font-size", (u) => u.label ? u.label.fontSize : null).style("stroke", "none").text((u) => u.label ? u.label.text : null);
    return (S = (T = e.modifiers).nodeLabel) == null || S.call(T, p), c;
  });
  return s == null || s.select(".node").classed("focused", (l) => l.isFocused), s == null || s.select(".node__label").attr("opacity", a ? 1 : 0), s;
}
const Ot = 500;
function At(e, t, i) {
  if (e.button !== void 0 && e.button !== 0)
    return;
  const n = t.lastInteractionTimestamp, r = Date.now();
  if (n === void 0 || r - n > Ot) {
    t.lastInteractionTimestamp = r;
    return;
  }
  t.lastInteractionTimestamp = void 0, i(t);
}
function Ct(e) {
  e == null || e.attr("transform", (t) => `translate(${t.x ?? 0},${t.y ?? 0})`);
}
function Gt({
  center: e,
  config: t,
  graph: i,
  onTick: n
}) {
  var c, h;
  const r = W(i.nodes), o = t.simulation.forces.centering;
  if (o && o.enabled) {
    const p = o.strength;
    r.force("x", H(() => e().x).strength(p)).force("y", V(() => e().y).strength(p));
  }
  const a = t.simulation.forces.charge;
  a && a.enabled && r.force(
    "charge",
    X().strength(a.strength)
  );
  const s = t.simulation.forces.collision;
  s && s.enabled && r.force(
    "collision",
    Y().radius(
      (p) => s.radiusMultiplier * g(t, p)
    )
  );
  const l = t.simulation.forces.link;
  return l && l.enabled && r.force(
    "link",
    q(i.links).id((p) => p.id).distance(t.simulation.forces.link.length).strength(l.strength)
  ), r.on("tick", () => n()), (h = (c = t.modifiers).simulation) == null || h.call(c, r), r;
}
function Bt({
  canvasContainer: e,
  config: t,
  min: i,
  max: n,
  onZoom: r
}) {
  var a, s;
  const o = U().scaleExtent([i, n]).filter((l) => {
    var c;
    return l.button === 0 || ((c = l.touches) == null ? void 0 : c.length) >= 2;
  }).on("start", () => e().classed("grabbed", !0)).on("zoom", (l) => r(l)).on("end", () => e().classed("grabbed", !1));
  return (s = (a = t.modifiers).zoom) == null || s.call(a, o), o;
}
class Vt {
  /**
   * Create a new controller and initialize the view.
   * @param container - The container the graph will be placed in.
   * @param graph - The graph of the controller.
   * @param config - The config of the controller.
   */
  constructor(t, i, n) {
    /**
     * Array of all node types included in the controller's graph.
     */
    d(this, "nodeTypes");
    d(this, "_nodeTypeFilter");
    d(this, "_includeUnlinked", !0);
    d(this, "_linkFilter", () => !0);
    d(this, "_showLinkLabels", !0);
    d(this, "_showNodeLabels", !0);
    d(this, "filteredGraph");
    d(this, "width", 0);
    d(this, "height", 0);
    d(this, "simulation");
    d(this, "canvas");
    d(this, "linkSelection");
    d(this, "nodeSelection");
    d(this, "markerSelection");
    d(this, "zoom");
    d(this, "drag");
    d(this, "xOffset", 0);
    d(this, "yOffset", 0);
    d(this, "scale");
    d(this, "focusedNode");
    d(this, "resizeObserver");
    if (this.container = t, this.graph = i, this.config = n, this.scale = n.zoom.initial, this.resetView(), this.graph.nodes.forEach((r) => {
      const [o, a] = n.positionInitializer(
        r,
        this.effectiveWidth,
        this.effectiveHeight
      );
      r.x = r.x ?? o, r.y = r.y ?? a;
    }), this.nodeTypes = [...new Set(i.nodes.map((r) => r.type))], this._nodeTypeFilter = [...this.nodeTypes], n.initial) {
      const {
        includeUnlinked: r,
        nodeTypeFilter: o,
        linkFilter: a,
        showLinkLabels: s,
        showNodeLabels: l
      } = n.initial;
      this._includeUnlinked = r ?? this._includeUnlinked, this._showLinkLabels = s ?? this._showLinkLabels, this._showNodeLabels = l ?? this._showNodeLabels, this._nodeTypeFilter = o ?? this._nodeTypeFilter, this._linkFilter = a ?? this._linkFilter;
    }
    this.filterGraph(void 0), this.initGraph(), this.restart(n.simulation.alphas.initialize), n.autoResize && (this.resizeObserver = new ResizeObserver(M(() => this.resize())), this.resizeObserver.observe(this.container));
  }
  /**
   * Get the current node type filter.
   * Only nodes whose type is included will be shown.
   */
  get nodeTypeFilter() {
    return this._nodeTypeFilter;
  }
  /**
   * Get whether nodes without incoming or outgoing links will be shown or not.
   */
  get includeUnlinked() {
    return this._includeUnlinked;
  }
  /**
   * Set whether nodes without incoming or outgoing links will be shown or not.
   * @param value - The value.
   */
  set includeUnlinked(t) {
    this._includeUnlinked = t, this.filterGraph(this.focusedNode);
    const { include: i, exclude: n } = this.config.simulation.alphas.filter.unlinked, r = t ? i : n;
    this.restart(r);
  }
  /**
   * Set a new link filter and update the controller's state.
   * @param value - The new link filter.
   */
  set linkFilter(t) {
    this._linkFilter = t, this.filterGraph(this.focusedNode), this.restart(this.config.simulation.alphas.filter.link);
  }
  /**
   * Get the current link filter.
   * @returns - The current link filter.
   */
  get linkFilter() {
    return this._linkFilter;
  }
  /**
   * Get whether node labels are shown or not.
   */
  get showNodeLabels() {
    return this._showNodeLabels;
  }
  /**
   * Set whether node labels will be shown or not.
   * @param value - The value.
   */
  set showNodeLabels(t) {
    this._showNodeLabels = t;
    const { hide: i, show: n } = this.config.simulation.alphas.labels.nodes, r = t ? n : i;
    this.restart(r);
  }
  /**
   * Get whether link labels are shown or not.
   */
  get showLinkLabels() {
    return this._showLinkLabels;
  }
  /**
   * Set whether link labels will be shown or not.
   * @param value - The value.
   */
  set showLinkLabels(t) {
    this._showLinkLabels = t;
    const { hide: i, show: n } = this.config.simulation.alphas.labels.links, r = t ? n : i;
    this.restart(r);
  }
  get effectiveWidth() {
    return this.width / this.scale;
  }
  get effectiveHeight() {
    return this.height / this.scale;
  }
  get effectiveCenter() {
    return k.of([this.width, this.height]).divide(2).subtract(k.of([this.xOffset, this.yOffset])).divide(this.scale);
  }
  /**
   * Resize the graph to fit its container.
   */
  resize() {
    const t = this.width, i = this.height, n = this.container.getBoundingClientRect().width, r = this.container.getBoundingClientRect().height, o = t.toFixed() !== n.toFixed(), a = i.toFixed() !== r.toFixed();
    if (!o && !a)
      return;
    this.width = this.container.getBoundingClientRect().width, this.height = this.container.getBoundingClientRect().height;
    const s = this.config.simulation.alphas.resize;
    this.restart(
      O(s) ? s : s({ oldWidth: t, oldHeight: i, newWidth: n, newHeight: r })
    );
  }
  /**
   * Restart the controller.
   * @param alpha - The alpha value of the controller's simulation after the restart.
   */
  restart(t) {
    var i;
    this.markerSelection = St({
      config: this.config,
      graph: this.filteredGraph,
      selection: this.markerSelection
    }), this.linkSelection = xt({
      config: this.config,
      graph: this.filteredGraph,
      selection: this.linkSelection,
      showLabels: this._showLinkLabels
    }), this.nodeSelection = zt({
      config: this.config,
      drag: this.drag,
      graph: this.filteredGraph,
      onNodeContext: (n) => this.toggleNodeFocus(n),
      onNodeSelected: this.config.callbacks.nodeClicked,
      selection: this.nodeSelection,
      showLabels: this._showNodeLabels
    }), (i = this.simulation) == null || i.stop(), this.simulation = Gt({
      center: () => this.effectiveCenter,
      config: this.config,
      graph: this.filteredGraph,
      onTick: () => this.onTick()
    }).alpha(t).restart();
  }
  /**
   * Update the node type filter by either including or removing the specified type from the filter.
   * @param include - Whether the type will be included or removed from the filter.
   * @param nodeType - The type to be added or removed from the filter.
   */
  filterNodesByType(t, i) {
    t ? this._nodeTypeFilter.push(i) : this._nodeTypeFilter = this._nodeTypeFilter.filter(
      (n) => n !== i
    ), this.filterGraph(this.focusedNode), this.restart(this.config.simulation.alphas.filter.type);
  }
  /**
   * Shut down the controller's simulation and (optional) automatic resizing.
   */
  shutdown() {
    var t, i;
    this.focusedNode !== void 0 && (this.focusedNode.isFocused = !1, this.focusedNode = void 0), (t = this.resizeObserver) == null || t.unobserve(this.container), (i = this.simulation) == null || i.stop();
  }
  initGraph() {
    this.zoom = Bt({
      config: this.config,
      canvasContainer: () => w(this.container).select("svg"),
      min: this.config.zoom.min,
      max: this.config.zoom.max,
      onZoom: (t) => this.onZoom(t)
    }), this.canvas = at({
      applyZoom: this.scale !== 1,
      container: w(this.container),
      offset: [this.xOffset, this.yOffset],
      scale: this.scale,
      zoom: this.zoom
    }), this.applyZoom(), this.linkSelection = wt(this.canvas), this.nodeSelection = $t(this.canvas), this.markerSelection = Tt(this.canvas), this.drag = ct({
      config: this.config,
      onDragStart: () => {
        var t;
        return (t = this.simulation) == null ? void 0 : t.alphaTarget(this.config.simulation.alphas.drag.start).restart();
      },
      onDragEnd: () => {
        var t;
        return (t = this.simulation) == null ? void 0 : t.alphaTarget(this.config.simulation.alphas.drag.end).restart();
      }
    });
  }
  onTick() {
    Ct(this.nodeSelection), Lt({
      config: this.config,
      center: this.effectiveCenter,
      graph: this.filteredGraph,
      selection: this.linkSelection
    });
  }
  resetView() {
    var t;
    (t = this.simulation) == null || t.stop(), w(this.container).selectChildren().remove(), this.zoom = void 0, this.canvas = void 0, this.linkSelection = void 0, this.nodeSelection = void 0, this.markerSelection = void 0, this.simulation = void 0, this.width = this.container.getBoundingClientRect().width, this.height = this.container.getBoundingClientRect().height;
  }
  onZoom(t) {
    var i, n, r;
    this.xOffset = t.transform.x, this.yOffset = t.transform.y, this.scale = t.transform.k, this.applyZoom(), (n = (i = this.config.hooks).afterZoom) == null || n.call(i, this.scale, this.xOffset, this.yOffset), (r = this.simulation) == null || r.restart();
  }
  applyZoom() {
    lt({
      canvas: this.canvas,
      scale: this.scale,
      xOffset: this.xOffset,
      yOffset: this.yOffset
    });
  }
  toggleNodeFocus(t) {
    t.isFocused ? (this.filterGraph(void 0), this.restart(this.config.simulation.alphas.focus.release(t))) : this.focusNode(t);
  }
  focusNode(t) {
    this.filterGraph(t), this.restart(this.config.simulation.alphas.focus.acquire(t));
  }
  filterGraph(t) {
    this.focusedNode !== void 0 && (this.focusedNode.isFocused = !1, this.focusedNode = void 0), t !== void 0 && this._nodeTypeFilter.includes(t.type) && (t.isFocused = !0, this.focusedNode = t), this.filteredGraph = dt({
      graph: this.graph,
      filter: this._nodeTypeFilter,
      focusedNode: this.focusedNode,
      includeUnlinked: this._includeUnlinked,
      linkFilter: this._linkFilter
    });
  }
}
function Xt({ nodes: e, links: t }) {
  return {
    nodes: e ?? [],
    links: t ?? []
  };
}
function Yt(e) {
  return {
    ...e
  };
}
function Dt(e) {
  return {
    ...e,
    isFocused: !1,
    lastInteractionTimestamp: void 0
  };
}
const Rt = {
  color: "lightgray",
  label: {
    color: "black",
    fontSize: "1rem",
    text: ""
  },
  isFocused: !1
};
function qt(e) {
  return Dt({
    ...Rt,
    ...e
  });
}
export {
  Vt as GraphController,
  it as Markers,
  st as PositionInitializers,
  P as createDefaultAlphaConfig,
  K as createDefaultForceConfig,
  J as createDefaultInitialGraphSettings,
  Xt as defineGraph,
  Ht as defineGraphConfig,
  Yt as defineLink,
  Dt as defineNode,
  qt as defineNodeWithDefaults
};
